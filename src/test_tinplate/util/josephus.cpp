#define PROBLEM "https://codeforces.com/gym/101955/problem/K"

#include "../../code/util/josephus.hpp"

int main() {
  u32 t_;
  std::cin >> t_;
  fle_ (u32, kase, 1, t_) {
    u64 n, m, k;
    std::cin >> n >> m >> k;
    std::cout << "Case #" << kase << ": " << tifa_libs::util::Josephus(n, k, m) + 1 << '\n';
  }
}

/*
今晚有 $n$ 个年轻人要参加彼得的篝火晚会. 他们决定玩一个古老的点数游戏, 在开始游戏之前, 这些年轻人将站在篝火周围形成一个圆圈, 第一个加入圆圈的人将开始游戏. 点数将从第一个人开始, 在圆圈中逆时针方向重复进行. 也就是说, 第一个人将在开始时报出一, 逆时针方向的第二个人将报出二, 以此类推, 直到一个可怜的人报出$k$, 随后离开圆圈成为旁观者. 游戏将继续进行, 剩下的人重复进行, 从逆时针方向中的下一个人开始, 他将成为新的第一个人, 方向相同, 直到所有年轻人离开圆圈为止
彼得想成为第 $m$ 个离开圆圈的人, 因为他坚信这个数字对他来说是幸运的. 作为一个精明的程序员, 你能指出他在游戏开始前应该站在什么地方, 以便他实现他的目标吗?
为了清晰起见, 假设加入圆圈的第一个人的索引是 $1$, 在他逆时针方向上的下一个人的索引是 $2$, 依此类推. 根据定义, 该方向上的最后一个人的索引应该是 $n$, 你的任务是确定彼得想要站的位置的索引

## 输入
输入包含多个测试用例, 第一行包含一个正整数$T$, 表示测试用例的数量, 最多为 $1000$
对于每个测试用例, 只有一行包含三个整数 $n, m$ 和 $k$, 其中 $1 \le n, m, k \le 10^{18}$ 且 $n \ge m$
保证所有测试用例中 $\min{m, k}$ (即$m$和$k$的最小值) 的总和不超过 $2 \times 10^6$

## 输出
对于每个测试用例, 输出一行, 包含"Case #x: y" (不带引号), 其中$x$是从$1$开始的测试用例编号, $y$是正确位置的索引

## 提示
样例展示了当 $(n, k)$ 分别为 $(10, 2)$ 和 $(10, 3)$ 时离开圆圈的顺序
*/

/*
20
10 1 2
10 2 2
10 3 2
10 4 2
10 5 2
10 6 2
10 7 2
10 8 2
10 9 2
10 10 2
10 1 3
10 2 3
10 3 3
10 4 3
10 5 3
10 6 3
10 7 3
10 8 3
10 9 3
10 10 3
===================
Case #1: 2
Case #2: 4
Case #3: 6
Case #4: 8
Case #5: 10
Case #6: 3
Case #7: 7
Case #8: 1
Case #9: 9
Case #10: 5
Case #11: 3
Case #12: 6
Case #13: 9
Case #14: 2
Case #15: 7
Case #16: 1
Case #17: 8
Case #18: 5
Case #19: 10
Case #20: 4
*/
