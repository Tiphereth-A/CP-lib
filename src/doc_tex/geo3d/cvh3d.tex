使用基于分治的 QuickHull 算法

使用时建议先对点随机扰动一下, 以防止初始单纯形构造有误

\begin{minted}{cpp}
rand::Gen<std::uniform_int_distribution<u32>> g(0, 1);
g.reset_seed();
for(auto& [x, y, z]: points) {
  x += g() ? eps_v<FP> : -eps_v<FP>;
  y += g() ? eps_v<FP> : -eps_v<FP>;
  z += g() ? eps_v<FP> : -eps_v<FP>;
}
\end{minted}

\paragraph{时间复杂度} 平均 \(O(n\log n)\), 最差 \(O(nh)\), 其中 \(n\) 为点的总数, \(h\) 为凸包上的点数. 对于随机数据来说速度很快

\paragraph{空间复杂度} \(O(n)\)

\paragraph{参考文献} \cite{barber1996quickhull}