#define PROBLEM "https://codeforces.com/gym/102001/problem/C"

#include "../../code/util/debruijn.hpp"

#include "../../code/rand/gen.hpp"

vecu prandom(u32 m, u32 l) {
  tifa_libs::rand::Gen<std::uniform_int_distribution<u32>> gen(0, m - 1);
  vecu ret(l);
  flt_ (u32, i, 0, l) ret[i] = gen();
  return ret;
}

int main() {
  u32 n, m, k;
  std::cin >> n >> m >> k;
  vecu a(m);
  for (auto& i : a) std::cin >> i;
  u32 l = n + k - 1;
  vecu ans = n <= 20 ? tifa_libs::util::deBruijn(n, m, l) : prandom(m, l);
  flt_ (u32, i, 0, l) std::cout << a[ans[i]];
  std::cout << '\n';
  return 0;
}

/*
阿育成功偷了布迪的宝箱, 准备揭开布迪隐藏的任何秘密. 不幸的是, 宝箱有一些安全系统, 防止任何未经授权的人 (例如阿育) 打开它
要解锁宝箱, 阿育必须输入一个正确的长度为 $N$ 的 PIN (个人识别码) , 当然, 她没有. 阿育别无选择, 只能尝试所有可能的 PIN 组合. 然而, 阿育注意到这个安全系统有一个有趣的 (老式) 机制
当你输入一个 $N$ 位数的 PIN 时, 它会自动且立即进行评估, 也就是说, 你不需要按下某个 "确认" 按钮来确认 PIN. 每当您输入的 PIN 错误时, 它会移除最旧 (第一个) 数字, 并将其余的所有数字向左移动, 因此, 您只需要再输入一个 (最后) 数字, 使其再次变为 $N$ 位数
例如, 假设 $N=4$. 如果我们输入 204320435, 则实际上测试了 6 个PIN (共 5 个不同的PIN)
- 测试的PIN = 2043
- 测试的PIN = 0432
- 测试的PIN = 4320
- 测试的PIN = 3204
- 测试的PIN = 2043
- 测试的PIN = 0435
注意, 在这个例子中, 2043 被测试了两次
作为一名计算机科学专业的学生, 阿育知道通过尝试所有可能的组合来找到正确的 PIN 可能非常耗时, 但是, 无奈之下, 没有其他方法. 阿育决定她想在第一天至少测试 $K$ 个不同的 PIN. 你的任务是通过简单地给出一个包含至少 $K$ 个不同 PIN 的字符串 $S$ 来帮助阿育. 阿育不在乎她要测试哪个 PIN (只要至少有 $K$ 个不同的 PIN) , 也不在乎 $S$ 中是否有任何 PIN 被测试多次, 但字符串 $S$ 需要尽可能短. 如果有多个可能的字符串 $S$, 你可以输出其中任何一个
请注意, 由于这个系统相当老旧, 可用的数字仅为 $0$ 到 $9$

## 输入
输入以一行包含三个整数开头: $N$ $M$ $K$ ($1 \le N \le 100000$, $1 \le M \le 10$, $1 \le K \le \min(M^N,100000)$), 分别表示 PIN 长度, 可用数字数量和要测试的 PIN 的最小数量. 接下来一行包含 $M$ 个整数: $A_i$ ($0 \le A_i \le 9$) , 表示可用数字. 您可以假设所有 $A_i$ 都是不同的. 您还可以假设所选择的 $N$, $M$ 和 $K$ 的值使得答案不超过 $100000$ 个数字

## 输出
在一行中输出最短的字符串, 该字符串包含至少 $K$ 个不同的 PIN 作为其子串. 如果有多个这样的字符串, 则可以输出任何一个

## 提示
#1: 447, 477, 744, 747, 774
#2: 12, 21, 23, 32, 34, 43, 45, 54, 55
#3: 353593, 935359
*/

/*
3 2 5
4 7
=========
7477447
*/

/*
2 5 9
1 2 3 4 5
===========
1234554321
*/

/*
6 3 2
9 3 5
=========
9353593
*/
